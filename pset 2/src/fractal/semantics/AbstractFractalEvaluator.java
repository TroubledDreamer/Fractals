/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package fractal.semantics;

import fractal.sys.FractalException;
import fractal.values.FractalPoint;
import fractal.values.FractalValue;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author newts
 */
public abstract class AbstractFractalEvaluator 
        implements Visitor<FractalState, FractalValue> {
    
    //FractalState state;
    // FractalPoint result;  // cumulative result
    final static int MODULO = 1000000007;
    
    PathHash hash;
    
    public AbstractFractalEvaluator() {
        hash = new PathHash();
    }
    
    @Override
    public FractalState mkDefaultState() {
        return new FractalState();
    }
    
//    public void resetResult() {
//        result = FractalPoint.ORIGIN;
//    }
    
    protected FractalPoint modAdd(FractalPoint p1, FractalPoint p2) {
        return new FractalPoint(
                modAdd(p1.getX(), p2.getX()),
                modAdd(p1.getY(), p2.getY())
        );
    }
    
    private float modAdd(float v1, float v2) {
        return (v1 + v2) % MODULO;
    }
    
    /**
     * Combine two point results and return the result. The method of combination
     * takes only points generated by drawing into account.  Non-point values 
     * are given a value equivalent to the origin.  There is no geometric meaning
     * to the output of this function; it should be regarded as a single step in
     * a kind of checksum process for the final result of a sequence of statements. 
     * @param p The existing result of a previous combination
     * @param v The new value to be combined
     * @return The result of combining the two values.
     */
    public final FractalPoint combine(FractalPoint p, FractalValue v) {
        final int MULTIPLIER = 10; // only previous value multiplied, creating asymmetry
        try {
            FractalPoint vp = v.pointValue();
            return modAdd(p.scale(MULTIPLIER), vp);
        } catch (FractalException fe) {
            return p;
        }
    }
    
//    /**
//     * 
//     * @param p
//     */
//    public void addToResult(FractalPoint p) {
//        result = modAdd(result, p);
//    }
    
}
